# 18738번(Special Game) 문제 : https://www.acmicpc.net/problem/18738
import sys

input = sys.stdin.readline

# 슬라이딩 윈도우(투 포인터)로 시간 복잡도를 O(N^2)(최악의 경우 O(N^3))에서 O(N)으로 개선합니다.

# 두 명의 플레이어가 번갈아 카드를 내고 승패를 겨루는 2인 제로섬 게임입니다.
# 양측 모두 완전 정보 하에서 최적 전략(미니맥스 알고리즘)을 따릅니다.
# 게임 규칙 : 드미트릭(Dmytryk)이 첫 라운드 선공이며, 각 라운드마다 선공이 카드를 내면 후공이 그 카드를 보고 자신의 카드를 냅니다.
# 각 라운드 승자는 더 큰 값을 낸 플레이어이고, 승자가 다음 라운드의 선공이 됩니다.
# 추가 규칙 : 후공 플레이어는 상대 카드보다 큰 카드를 하나라도 갖고 있다면 반드시 그 중 하나를 내야 합니다.
# 목표 : 두 플레이어 모두 자기 승리 라운드 수를 최대화하려고 하며, 최종적으로 드미트릭이 최적 플레이 시 이길 수 있는 최대 라운드 수를 구합니다.

N:int = int(input().rstrip())
L1:list = list(map(int, input().split())) # 드미트릭의 카드 목록
L2:list = list(map(int, input().split())) # 페트로의 카드 목록

# 입력된 카드들을 정렬합니다. 
# 정렬해 두면 최소/최대 카드를 빠르게 비교하며 전략을 세울 수 있습니다.
L1.sort()
L2.sort()

# turn 변수 : 0 = 드미트릭 차례(선공), 1 = 페트로 차례(선공 아님, 즉 후공).
# 초기에는 드미트릭이 첫 턴 선공이므로 turn = 0으로 시작합니다.
turn:int = 0
result:int = 0  # 드미트릭의 승리 횟수를 셀 변수 (최종적으로 출력될 값)

while True :
    if turn == 0 : # 드미트릭의 선공 턴
        # (1) 드미트릭이 더 이상 낼 카드가 없거나, 드미트릭의 가장 큰 카드도 페트로의 가장 작은 카드보다 작다면,
        #     드미트릭은 남은 라운드를 모두 패배하므로 게임 종료 (더 이상 승수를 늘릴 수 없음).
        if not L1 or L1[-1] < L2[0] :
            break

        # (2) 드미트릭의 가장 작은 카드가 페트로의 가장 큰 카드보다 크다면,
        #     드미트릭의 모든 남은 카드가 페트로 카드보다 크다는 뜻이므로 남은 모든 라운드를 드미트릭이 승리합니다.
        if L1[0] > L2[-1]:
            result += len(L1) # 남은 모든 카드 수 만큼 드미트릭 승리 횟수에 더함
            break

        number:int = len(L1)

        # --- O(number) 투 포인터로 (i, j) 최적 쌍을 직접 찾기 ---
        # j는 "L2[j] > L1[i]"를 만족하는 첫 인덱스(upper_bound)를
        # i가 증가할 때 단조 증가로 한 번만 전진시켜 총 O(number)에 찾습니다.
        best_diff = -10**9
        best_dmytryk = 0
        best_petro = 0
        j = 0
        for i in range(number):
            # L2[j] <= L1[i] 인 동안 전진 → 첫 L2[j] > L1[i]에서 정지
            while j < number and L2[j] <= L1[i]:
                j += 1
            if j < number:
                diff = i - j
                if diff > best_diff:
                    best_diff = diff
                    best_dmytryk = i
                    best_petro = j
            else:
                # 더 이상 어떤 L2도 L1[i]를 이길 수 없음 → 이후 i에서도 불가능
                break
        # -------------------------------------------------------

        # 위에서 결정한 최적의 카드 페어를 실제로 게임에서 내는 것으로 간주하고, 두 플레이어의 카드 목록에서 제거합니다.
        L1.pop(best_dmytryk)
        L2.pop(best_petro)

        # 한 라운드 진행 후 남은 라운드 수는 number - 1입니다.
        # result에 number - 1을 더해주는데, 이는 현재 라운드에서의 선택으로 인해 드미트릭이 확보하게 된 향후 승리 기대치를 누적하는 역할을 합니다.
        result += number - 1

        # 이 라운드에서는 드미트릭이 선공으로 카드를 냈고, 페트로가 그보다 큰 카드로 대응했다면 페트로가 승리한 것입니다.
        # 라운드 승자가 다음 라운드 선공이 되므로, 이제 turn = 1로 설정하여 다음 라운드에서 페트로가 선공이 되도록 합니다.
        turn = 1

    else : # 페트로의 선공 턴 (드미트릭은 후공)
        # (1) 페트로가 낼 카드가 없거나, 페트로의 가장 큰 카드가 드미트릭의 가장 작은 카드보다 작다면,
        #     페트로는 더 이상 이길 수 없으므로 게임 종료.
        if not L2 or L2[-1] < L1[0]:
            break

        # (2) 페트로의 가장 작은 카드가 드미트릭의 가장 큰 카드보다 크다면,
        #     페트로의 남은 모든 카드가 드미트릭의 카드보다 크다는 뜻이므로 남은 모든 라운드는 페트로가 승리하게 됩니다.
        if L2[0] > L1[-1] :
            result -= len(L2)        # 남은 라운드 모두 드미트릭이 패배하므로, 드미트릭의 승리 횟수에서 그만큼 빼줍니다.
            break

        number:int = len(L2)

        # --- O(number) 투 포인터(대칭) ---
        best_diff = -10**9
        best_petro = 0
        best_dmytryk = 0
        j = 0
        for i in range(number):
            while j < number and L1[j] <= L2[i]:
                j += 1
            if j < number:
                diff = i - j
                if diff > best_diff:
                    best_diff = diff
                    best_petro = i
                    best_dmytryk = j
            else:
                break
        # -----------------------------------

        # 선택된 카드 쌍을 제거하여 라운드를 진행합니다.
        L1.pop(best_dmytryk)
        L2.pop(best_petro)

        # 드미트릭 입장에서 패배를 각오한 한 라운드를 치른 것이므로, 남은 라운드 수 (number - 1)만큼 승리 기대치를 감소시킵니다.
        result -= number - 1

        # 이 라운드에서는 페트로가 선공이었고, 드미트릭이 더 큰 카드로 승리했다면 드미트릭이 라운드 승자입니다.
        # 승자인 드미트릭이 다음 라운드 선공이 되므로, turn = 0으로 설정합니다.
        turn = 0

# 반복문 종료 – 모든 라운드 진행 완료 또는 승패가 결정되어 중단됨.
# result에는 최적 플레이 가정 시 드미트릭의 최대 승리 횟수가 저장되어 있습니다.
print(result)

"""
[예시]
예를 들어 n = 3, 드미트릭의 카드가 [1, 4, 6], 페트로의 카드가 [2, 3, 5]인 경우를 가정해보겠습니다.
두 플레이어 모두 최선의 전략으로 게임을 진행하면 :
- *라운드 1* : 드미트릭(선공)이 가장 작은 카드 1을 내면, 페트로(후공)는 더 큰 카드가 있으므로 규칙에 따라 반드시 2를 내야 합니다. 
결과는 2 > 1로 페트로 승리이고, 다음 라운드는 페트로가 선공이 됩니다.
- *라운드 2* : 페트로(선공)가 남은 카드 중 가장 작은 3을 내면, 드미트릭(후공)은 3보다 큰 카드를 가지고 있으므로 4를 내서 대응합니다.
4 > 3으로 드미트릭이 승리하여, 다음 라운드는 드미트릭이 다시 선공을 잡습니다.
- *라운드 3* : 드미트릭(선공)의 남은 카드 6을 내면, 페트로의 남은 카드 5는 6보다 작아서 이길 수 있는 카드가 없습니다.
따라서 페트로는 5를 낼 수밖에 없고, 6 > 5로 드미트릭이 승리합니다.
이 경우 드미트릭은 총 2번 이겨서, 출력될 결과값은 2가 됩니다.
"""

"""
게임 이론적 분석 :
본 코드는 두 플레이어가 완전 정보 하에서 최적 플레이(미니맥스 전략)을 펼친다고 가정하고, 
그 결과 드미트릭이 얻을 수 있는 최대 승리 횟수를 계산합니다. 
알고리즘이 이러한 방식으로 작성된 이유를 예시와 함께 증명/유도해 보겠습니다.

1. 종료 조건 (Break 조건)의 타당성
   - 드미트릭의 가장 큰 카드보다 페트로의 가장 작은 카드가 더 크다면 (*L1[-1] < L2[0]*), 
   이는 드미트릭이 가진 모든 카드가 페트로의 모든 카드보다 작다는 의미입니다. 
   이 경우 드미트릭은 어떤 카드를 내더라도 페트로가 그보다 큰 카드로 대응하여 매 라운드 패배하게 됩니다. 
   따라서 남은 라운드를 모두 패배하는 것이 확정되므로 즉시 루프를 종료합니다. 
   - 반대로 드미트릭의 가장 작은 카드가 페트로의 가장 큰 카드보다 크다면 
   (*L1[0] > L2[-1]*), 드미트릭이 가진 모든 카드가 페트로의 카드보다 큽니다. 
   즉 남은 모든 라운드에서 드미트릭은 상대보다 큰 카드를 내어 승리할 수 있음을 의미합니다. 
   따라서 남은 카드 수 만큼을 드미트릭의 승수에 더하고 게임을 종료해도 문제가 없습니다. 
   이러한 종료 조건들은 게임 이론적으로도 명백한데, 한 쪽의 카드들이 전부 상대에게 우위 또는 열위에 있는 극단 상황에서는 
   더 이상 선택의 여지가 없이 결과가 정해지기 때문입니다.

2. 드미트릭 차례의 최적 전략 (선공일 때)
   드미트릭이 선공으로 카드를 낼 때, 상대 페트로는 그 카드를 보고 반드시 이길 수 있는 카드를 내도록 강제됩니다 (있다면).
   드미트릭은 자신의 카드 중 어떤 것을 내느냐에 따라 페트로의 대응이 달라지고, 
   결국 향후 라운드의 유리함이 좌우됩니다. 
   코드는 `i - j` 값이 최대가 되는 (드미트릭의 카드 인덱스 i와 페트로의 대응 카드 인덱스 j의 차이를 극대화하는) 카드를 선택하는데, 
   이것이 곧 드미트릭의 향후 승리를 극대화하는 선택임을 보일 수 있습니다.

   - `candidates` 리스트에는 드미트릭의 각 카드 `L1[i]`에 대해 
   페트로가 그보다 크면서 내게 될 첫 번째 카드 `L2[j]`의 인덱스 쌍 `(i, j)`가 저장됩니다. 
   여기서 j는 규칙에 따라 [페트로가 이길 수 있는 가장 작은 카드]를 낸다는 점을 반영합니다. 
   (페트로도 최적으로 플레이하므로 굳이 더 큰 카드를 내어 손해 볼 이유가 없습니다.)
   - 이제 `(i, j)` 중에서 `i - j`를 최대화하는 쌍을 선택합니다. 
   이 값이 크다는 것은 드미트릭이 비교적 높은 값을 가진 카드를 냈을 때 
   페트로가 간신히 그보다 약간 큰 카드로 이긴 상황을 뜻합니다. 
   즉 드미트릭은 높은 카드 하나를 희생하여 페트로로 하여금 그보다 조금 큰 좋은 카드 하나를 소모하게 만들었다는 의미입니다. 
   그 결과 ->
     - 페트로의 최상위급 카드가 아니라 그보다는 낮지만 
     드미트릭의 카드보다 약간 큰 정도의 카드를 빼앗아냄으로써, 
     페트로의 전체 카드 전력은 감소합니다.
     - 드미트릭은 자신의 가장 큰 카드들은 내지 않고 남겨두었으므로, 
     이후 라운드에서 여전히 강한 패를 활용할 수 있습니다.
   - 반대로 `i - j` 차이가 작은 선택은 페트로가 상대적으로 더 큰 인덱스(j)가 높은 카드로 대응한다는 의미인데, 
   이는 드미트릭이 너무 낮은 카드를 내었거나 최적의 희생이 아니라는 신호입니다. 
   예를 들어 드미트릭이 너무 작은 카드를 내면 (i가 매우 작을 때), 
   페트로는 그보다 약간만 큰 (j도 작거나 비슷한) 카드를 내어 이기고 자신의 큰 카드들을 아껴둘 수 있습니다. 
   드미트릭은 작은 카드를 잃고도 상대의 강력한 카드들은 여전히 남게 되어 이후 라운드 승리에 도움이 되지 않습니다. 
   따라서 드미트릭 입장에서는 [너무 낮은 카드를 첫 수로 내는 것은 최선이 아니며], 
   적절히 높은 카드를 내서 상대의 중요한 카드 하나를 끌어내 소모시키는 것이 유리합니다.
   - 이러한 전략은 미니맥스 관점에서 최적입니다. 
   드미트릭은 자신이 한 라운드를 내주더라도 
   (`result += number - 1`에서 현재 라운드를 제외한 나머지 라운드 수만큼 승리 기대치를 더해주는 것은, 
   이번 라운드는 패배하되 이후 남은 라운드 `number-1`개를 모두 승리하는 시나리오를 반영합니다), 
   앞으로 펼쳐질 `number-1`번의 대결에서 최대한 많은 승리를 거두는 쪽으로 현재 수를 선택합니다. 
   실제로도 드미트릭이 최선의 수를 두었다면, 이후 페트로가 아무리 대응해도 드미트릭이 확보할 수 있는 승수 총량이 그 선택으로 인해 극대화됩니다.

   - 예시 : 드미트릭의 카드가 `[1, 4, 6]`, 페트로의 카드가 `[2, 3, 5]`인 경우를 다시 살펴봅시다. 
   위 코드의 로직에 따르면 드미트릭은 첫 라운드에 `L1[0] = 1` (i=0) 을 내게 됩니다. 
   왜냐하면 후보 쌍 `(i, j)`들 중 (0,0) -> i-j=0, (1,2) -> i-j=-1 이고 i-j 값이 최대인 (0,0)을 택하기 때문입니다. 
   드미트릭이 1을 내면 페트로는 2로 대응하여 이기지만, 드미트릭은 이후 라운드에서 승리를 극대화할 수 있는 상황을 만들게 됩니다. 
   실제 진행을 보면 페트로가 2를 소모한 뒤 남은 카드 상황은 드미트릭 [4, 6], 페트로 [3, 5]이고, 다음은 페트로의 선공입니다. 
   이후 게임은 드미트릭이 두 라운드를 모두 이겨 총 2승을 거둘 수 있었고, 
   이는 드미트릭이 처음부터 가장 큰 카드 6을 냈을 때보다 더 많은 승리를 확보한 결과입니다. 
   만약 드미트릭이 첫 라운드에 6을 냈다면 (페트로는 이길 카드가 없어 드미트릭 승), 
   이후 라운드들에서 드미트릭은 남은 작은 카드로 인해 한 번밖에 승리하지 못해 최종 1승에 그쳤을 것입니다. 
   이 예시는 왜 드미트릭이 섣불리 확실한 한 판 승리를 가져가기보다는, 
   오히려 작은 카드를 희생하여 상대의 카드를 빼두고 향후 더 많은 승리를 노리는 전략이 최적인지를 보여줍니다.

3. 페트로 차례의 최적 전략 (후공일 때)
   페트로가 선공으로 카드를 내는 상황은 드미트릭 입장에서 반대 대칭의 국면입니다. 
   이때 페트로는 자신이 이길 수 없는 라운드라도 드미트릭의 강한 카드를 빼도록 유도하는 선택을 하게 됩니다. 
   코드에서는 마찬가지로 `i - j` 값을 최대화하는 `(i, j)`를 선택하는데, 
   여기서는 i가 페트로의 카드, j가 대응하는 드미트릭의 카드 인덱스입니다. 
   이 값이 크다는 것은 페트로가 비교적 큰 값을 낸 덕분에 드미트릭이 간신히 그보다 큰 한 장으로 이기는 경우를 의미합니다. 
   즉 페트로는 한 라운드를 희생하면서 드미트릭으로 하여금 그의 높은 카드 하나를 소모하게 만드는 것입니다. 
   이는 페트로 입장에서 드미트릭의 향후 승리 가능성을 최소화하는 최적 대응입니다. 
   예를 들어 드미트릭의 남은 카드 중 가장 큰 카드보다 살짝 작은 값을 페트로가 내게 되면, 
   드미트릭은 이기기 위해 자신의 가장 큰 카드를 써야만 하고 그 판을 이기더라도 중요한 자원을 잃게 됩니다.

   - 페트로의 턴에서도 종료 조건이 존재하는데, 
   `L2[-1] < L1[0]`인 경우 (페트로의 최대값 < 드미트릭의 최소값)은 페트로가 더 이상 이길 수 없음을 의미하므로 
   남은 판은 모두 드미트릭의 승리가 됩니다. 
   반면 `L2[0] > L1[-1]` (페트로 최솟값 > 드미트릭 최댓값)은 페트로의 모든 카드가 
   드미트릭의 것보다 커서 남은 라운드를 모두 가져갈 수 있는 상황이므로, 
   남은 라운드 수만큼을 `result`에서 빼주고 종료하는 것이 합리적입니다 
   (드미트릭의 승수 입장에서 그만큼 감소). 
   - 위 두 조건 외의 일반적인 상황에서, 페트로는 자신의 각 카드 `L2[i]`에 대해 드미트릭이 이길 수 있는 첫 카드 `L1[j]`를 찾고 `(i, j)` 후보로 삼습니다. 
   이후 `i - j` 최대인 쌍을 선택하는데, 이는 앞서 설명한 대로 **드미트릭에게 가장 불리한 교환을 강요하는 전략**입니다. 
   그렇게 페트로가 카드를 내고 드미트릭이 더 큰 카드로 이겨 한 라운드가 끝나면 (`result -= number - 1`는 이번 라운드를 드미트릭이 이겼으므로 
   남은 `number-1` 라운드에 대한 승리 기대치를 감소시킨다는 의미입니다), 
   다음 라운드는 드미트릭이 선공이 됩니다.

4. 전략의 최적성 증명 개관
   위 과정을 통해 두 플레이어는 번갈아가며 자신에게 유리한 쪽으로 게임 전개를 이끌어갑니다. 
   드미트릭은 매 선공 턴마다 현재 한 라운드를 포기하더라도 이후 더 많은 승리를 얻는 수를 선택하고, 
   페트로는 매 선공 턴마다 한 라운드를 내주더라도 드미트릭의 강력한 패를 소진시켜 향후 승리를 저지하는 수를 선택합니다. 
   이러한 선택 기준은 **미니맥스 알고리즘**과 맥락을 같이 합니다. 
   각각의 턴에서 플레이어는 자신의 승리를 최대화 (상대의 승리는 최소화) 하는 쪽으로 
   합리적인 결정을 내리는 것입니다. 
   이 알고리즘이 최적이라는 것은 귀납적(수학적 귀납법)으로 증명할 수 있습니다. 
   카드 장수가 매우 적은 경우부터 시작하여, 
   각 단계에서 위와 같은 전략을 취할 때 얻는 승수는 다른 어떤 전략을 취했을 때보다 많거나 적어도 동일함을 보이면 됩니다. 
   예컨대 카드 1장 대 1장인 경우 자명하며, 임의의 n장에 대해 성립한다고 가정하면 
   n+1장일 때도 첫 번째 라운드에서 본 알고리즘의 선택(i - j 최대인 선택)이 아니었다면 상대가 그에 맞서 더 크게 득을 보는 대응을 할 수 있어 
   결국 드미트릭의 최종 승수가 감소하게 됨을 논리적으로 전개할 수 있습니다. 
   따라서 드미트릭은 물론 페트로의 입장에서도 본인의 이득을 극대화하는 이 그리디(greedy)한 선택이 
   최종적으로 최적 전략이 됩니다.

정리하면, 해당 코드는 모든 경우의 수를 탐색하지 않고도 각 라운드에서의 최적 수만을 골라내는 그리디 알고리즘(게임 이론 바탕)을 통해, 복잡한 미니맥스 전략을 효과적으로 구현**한 것입니다. 각 라운드에서 카드 페어를 이런 방식으로 선택함으로써, 
둘의 최적 플레이 과정에서 드미트릭의 최대 승리 횟수를 올바르게 계산해냅니다.
"""